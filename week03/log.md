## Day 8: 継承とポリモーフィズムの学習・実装ログ

### 概要

- C#における継承・ポリモーフィズムの基本的な概念を確認・整理。
- `virtual` / `override` / `new` の違いを明確にし、挙動の違いを検証。
- 実装を通じて、リストによる多態性の動作と、変数の型による動作の違いを把握。
- InterfaceやCompositionとの比較・使い分けも学習。

### 実装内容

| ファイル名         | 内容                                                          |
|--------------------|---------------------------------------------------------------|
| `Animal.cs`        | `Name` プロパティと `virtual Speak()` を定義                  |
| `Dog.cs`, `Cat.cs` | `override` を使って `Speak()` をカスタマイズ                  |
| `Bird.cs`          | `new` を使って `Speak()` を再定義（ポリモーフィズム対象外）   |
| `Program.cs`       | `List<Animal>` による動的ディスパッチ検証と `Bird` の挙動確認 |

### 実行結果と考察

```csharp
List<Animal> animals = new List<Animal>
{
    new Dog { Name = "ポチ" },
    new Cat { Name = "タマ" },
    new Bird { Name = "ピーちゃん" }
};

foreach (var animal in animals)
{
    animal.Speak(); 
    // Dog, Cat → override によりそれぞれの Speak() が呼ばれる（ポリモーフィズム成立）
    // Bird → new により基底の Speak() が呼ばれる（Animal型として扱ったため）
}

Bird bird = new Bird { Name = "真・ピーちゃん" };
bird.Speak(); // → "ピヨ！"（Bird型で呼び出すと new に定義された方が使われる）
```

- `override`は多態性を成立させるのに必要。
- `new`は元のメソッドを「隠す」だけで、基底型として使うと元のメソッドが呼ばれる。
- 変数の型が何かによって呼び出されるメソッドが変わるというのは重要な観点。

### 学んだこと・気付き
- `override`を使うことでポリモーフィズムを安全かつ正確に実現できる。
- `new`は基本的に推奨されない設計。どうしても必要なとき以外は避ける。
- 継承は「is-a」関係が自然なときに有効。過度に使うと保守性が落ちる。
- 実務では`ControllerBase`,`DbContext`などのフレームワーク設計上の継承がよく登場する。
- 委譲（Composition）やインターフェース（interface）の方が柔軟で安全な場合が多い。

### README整理
- 学習内容を`week03/InheritanceBasics/README.md`にまとめて記録。
- `Interface`・`Compsition`との比較表や実装例も記載。
- 実務で継承を使うケース、使わない方がいいケース等も実例を交えて整理。

### 今後の展望
- 次回は`LINQ`の基本（`Select`/`Where`/`OrderBy`等）を学習予定。
- クラス設計とLINQの組み合わせ（例:`OfType<T>()`による型分岐処理など）も試していく。
- ポートフォリオ用の学習リポジトリとして、整備と記録の両面を今後も強化。

---

## Day 9～11: LINQ 実践編 学習・実装ログ

### 概要
- LINQ の基本操作（絞り込み・投影・ソート・グループ化・結合）の概念を確認・整理。  
- メソッド構文とクエリ構文の違いを実装で比較。  
- 遅延実行 vs 即時実行の違いを検証。  
- 匿名型、let 句、Aggregate、複合キーによる集計など発展要素を学習。

---

### 実装内容

| ファイル名     | 内容                                                                                                               |
|---------------|--------------------------------------------------------------------------------------------------------------------|
| `Program.cs`  | - `products`／`stocks` リスト準備<br>- メソッド構文版・クエリ構文版サンプル実装<br>- 練習課題（遅延 vs 即時実行、Aggregate、複合キーグループ化）の実装 |

---

### 実行結果と考察

```text
【果物（価格昇順）】
バナナ：80円
リンゴ：120円

【果物2（価格昇順）】
バナナ：80円
リンゴ：120円

【カテゴリー別 平均価格】
果物 -> 100.0円
飲料 -> 175.0円
食品 -> 100.0円

【カテゴリー別2 平均価格】
果物 -> 100.0円
飲料 -> 175.0円
食品 -> 100.0円

【在庫情報】
リンゴ: 価格=120円, 在庫数=50
牛乳: 価格=200円, 在庫数=20
パン: 価格=100円, 在庫数=30

【在庫情報2】
リンゴ: 価格=120円, 在庫数=50
牛乳: 価格=200円, 在庫数=20
パン: 価格=100円, 在庫数=30

遅延実行:
1
3
5

即時実行後に7追加:
1
3
5

文字列の連結
リンゴ,バナナ,牛乳,ヨーグルト,パン

複数キーによるグループ化
果物 / 100～200円 → 件数:1, 平均:120.0円
果物 / ～99円 → 件数:1, 平均:80.0円
飲料 / 200円～ → 件数:1, 平均:200.0円
飲料 / 100～200円 → 件数:1, 平均:150.0円
食品 / 100～200円 → 件数:1, 平均:100.0円
```
- 即時実行はするタイミングが重要（こまめにやりすぎると重いクエリ処理が何回も行われる可能性がある）
- `GroupBy`は複数項目選択することで、
  ```
  A 100未満 ...
  A 100以上 ...
  B 100未満 ...
  ...
  ```
  のように様々な条件付けができる。
- `Select`では自分（チーム）が分かりやすいプロパティ名を作成して値を格納可能。
- クエリ構文はSQL方式で書けるため、場合によっては可読性の向上が見込める。

### 実装概要
- 絞り込み＋ソート：Where → OrderBy（または from → orderby）で直感的に記述
- 集計：GroupBy と匿名型 Select でカテゴリ別平均価格を算出
- 結合：Join（または join）で在庫リストと内部結合

### 学んだこと・気付き
- メソッド構文 vs クエリ構文のメリット／デメリットを体感
- 遅延実行（Where のみ）と即時実行（ToList()）の動作タイミングを理解
- 匿名型で一時オブジェクトを作成し、Select で投影可能
- let 句で中間結果を変数化して可読性向上
- 複合キー（カテゴリ＋価格帯）での GroupBy による詳細集計ができるようになった
- Join によるリスト同士の内部結合方法を習得

### README整理
- README.md に **Day9～11: LINQ 実践編** セクションを追加
- LINQ の概要、主要演算子一覧、メソッド構文／クエリ構文の比較をまとめる
- サンプルコード例と実行結果を掲載
