## Day 8: 継承とポリモーフィズムの学習・実装ログ

### 概要

- C#における継承・ポリモーフィズムの基本的な概念を確認・整理。
- `virtual` / `override` / `new` の違いを明確にし、挙動の違いを検証。
- 実装を通じて、リストによる多態性の動作と、変数の型による動作の違いを把握。
- InterfaceやCompositionとの比較・使い分けも学習。

### 実装内容

| ファイル名         | 内容                                                          |
|--------------------|---------------------------------------------------------------|
| `Animal.cs`        | `Name` プロパティと `virtual Speak()` を定義                  |
| `Dog.cs`, `Cat.cs` | `override` を使って `Speak()` をカスタマイズ                  |
| `Bird.cs`          | `new` を使って `Speak()` を再定義（ポリモーフィズム対象外）   |
| `Program.cs`       | `List<Animal>` による動的ディスパッチ検証と `Bird` の挙動確認 |

### 実行結果と考察

```csharp
List<Animal> animals = new List<Animal>
{
    new Dog { Name = "ポチ" },
    new Cat { Name = "タマ" },
    new Bird { Name = "ピーちゃん" }
};

foreach (var animal in animals)
{
    animal.Speak(); 
    // Dog, Cat → override によりそれぞれの Speak() が呼ばれる（ポリモーフィズム成立）
    // Bird → new により基底の Speak() が呼ばれる（Animal型として扱ったため）
}

Bird bird = new Bird { Name = "真・ピーちゃん" };
bird.Speak(); // → "ピヨ！"（Bird型で呼び出すと new に定義された方が使われる）
```

- `override`は多態性を成立させるのに必要。
- `new`は元のメソッドを「隠す」だけで、基底型として使うと元のメソッドが呼ばれる。
- 変数の型が何かによって呼び出されるメソッドが変わるというのは重要な観点。

### 学んだこと・気付き
- `override`を使うことでポリモーフィズムを安全かつ正確に実現できる。
- `new`は基本的に推奨されない設計。どうしても必要なとき以外は避ける。
- 継承は「is-a」関係が自然なときに有効。過度に使うと保守性が落ちる。
- 実務では`ControllerBase`,`DbContext`などのフレームワーク設計上の継承がよく登場する。
- 委譲（Composition）やインターフェース（interface）の方が柔軟で安全な場合が多い。

### README整理
- 学習内容を`week03/InheritanceBasics/README.md`にまとめて記録。
- `Interface`・`Compsition`との比較表や実装例も記載。
- 実務で継承を使うケース、使わない方がいいケース等も実例を交えて整理。

### 今後の展望
- 次回は`LINQ`の基本（`Select`/`Where`/`OrderBy`等）を学習予定。
- クラス設計とLINQの組み合わせ（例:`OfType<T>()`による型分岐処理など）も試していく。
- ポートフォリオ用の学習リポジトリとして、整備と記録の両面を今後も強化。

---

## Day 9: LINQ 実践編の学習・実装ログ

### 概要
- LINQ の基本操作（絞り込み・投影・ソート・グループ化・結合）を実装で確認  
- 遅延実行と即時実行の違いを体感  
- 匿名型と式体メンバー構文を用いたコードの可読性向上を学習  

### 実装内容

| ファイル名     | 内容                                                                                                   |
|---------------|--------------------------------------------------------------------------------------------------------|
| `Program.cs`  | - `products` リストの準備<br>- `.Where`＋`.OrderBy`＋`.ToList()` による絞り込み・ソート<br>- `.GroupBy`＋`.Select` によるカテゴリ別平均価格集計<br>- `.Join` による在庫リストとの内部結合 |
| `Product.cs`  | - 読み取り専用プロパティで商品情報を保持（`Name`, `Price`, `Category`）                                   |
| `Stock.cs`    | - `ProductName`, `Quantity` を保持する在庫モデル                                                       |

### 実行結果と考察

```text
【果物（価格昇順）】
バナナ：80円
パン：100円
リンゴ：120円

【カテゴリー別 平均価格】
果物 → 100.0円
飲料 → 175.0円
食品 → 100.0円

【在庫情報】
リンゴ：価格=120円, 在庫数=50
牛乳：価格=200円, 在庫数=20
パン：価格=100円, 在庫数=30
```

- 絞り込み＋ソート：`Where` → `OrderBy` のチェーンで直感的に記述可能
- 匿名型＋集計：`GroupBy` の戻り値 `g` に対し `g.Key`／`g.Average(...)` を使って簡易的に統計を取得
- 内部結合：`Join` で外部リストとキー一致のみを結合し、必要な情報だけをまとめられる

### 学んだこと・気付き
- 遅延実行 vs 即時実行：`ToList()` 呼び出し時にのみクエリが評価される
- Select による投影：匿名型を使えば一時的なデータ構造を手軽に定義できる
- GroupBy の扱い：`IEnumerable<IGrouping<TKey,TSource>>` から `g.Key`／`g.Count()`／`g.Average()` などで要素を操作
- Join のシグネチャ：`inner`, `outerKeySelector`, `innerKeySelector`, `resultSelector` の順で指定

### 今後の展望
- 時間が確保できなかったため複数日程に分けてLINQ範囲を勉強する
- 練習課題への挑戦：`Aggregate`, `GroupJoin`（左外部結合）, `OfType<T>` など発展的演算子の実装
- パフォーマンス検証：遅延実行のオーバーヘッド確認と必要時の `ToList()` キャッシュ戦略
- UI/DB との連携：LINQ to Objects から LINQ to Entities への橋渡し、DTO/`record` への置き換え
- 翌週以降：Day10～11 でオブジェクト指向＋LINQ の組み合わせ例を深堀り予定
